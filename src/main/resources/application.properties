spring.application.name=matchpoint

# Spring DataSource Configuration
## Render provides DATABASE_URL in format: postgres://user:pass@host:port/dbname
# Fallback defaults are for local development using MySQL. In production Render will override with DATABASE_URL.
# For local MySQL: user=root password=123456789

# Configuración para producción (Render)
# Use environment variables in production. Make username/password optional so
# app can parse them from DATABASE_URL when provided, avoiding placeholder
# resolution errors during startup when only DATABASE_URL is present.
# Configuración para producción (Render)
# `DATABASE_URL` se usa directamente en `DatabaseConfig`. No definir
# `spring.datasource.*` aquí evita que valores vacíos sobrescriban
# configuraciones locales en `application-local.properties`.
# El driver se selecciona automáticamente según la URL (PostgreSQL en producción)



# Spring Data JPA Configuration
spring.jpa.show-sql=true

#Spring Data JPA Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.open-in-view=true
# If you need to force a dialect, uncomment one of the following depending on your DB:
# For MySQL: spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
# For PostgreSQL: spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.naming.physical-strategy=com.upc.matchpoint.shared.infrastructure.persistence.jpa.configuration.strategy.SnakeCaseWithPluralizedTablePhysicalNamingStrategy

# Application Information for Documentation

# Elements take their values from maven pom.xml build-related information
documentation.application.description=@project.description@
documentation.application.version=@project.version@

# JWT Configuration Properties
# Use environment variable for production, fallback for local dev
authorization.jwt.secret=${AUTHORIZATION_JWT_SECRET:WriteHereYourSecretStringForTokenSigningCredentials}
authorization.jwt.expiration.days=${AUTHORIZATION_JWT_EXPIRATION_DAYS:7}